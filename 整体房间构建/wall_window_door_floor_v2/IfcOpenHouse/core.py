# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_generation.ipynb.

# %% auto 0
__all__ = ['project_name', 'author_details', 'author_role', 'organization_details', 'site_name', 'building_name', 'storey_name',
           'storey_size', 'wall_thickness', 'footing_ledge', 'footing_size', 'roof_ledge', 'roof_thickness',
           'roof_angle', 'roof_angle_sin', 'roof_angle_cos', 'roof_height', 'roof_size', 'door_horizontal_offset',
           'window_base_height', 'right_window_horizontal_offset', 'stair_width', 'wall_colour', 'footing_colour',
           'roof_colour', 'terrain_colour', 'door_colour', 'window_colour', 'stair_colour', 'terrain_build_method',
           'ios', 'file', 'project', 'ctx', 'body', 'application', 'person', 'organisation', 'user', 'actor', 'site',
           'building', 'storey', 'pset_site_common', 'south_wall', 'south_wall_representation', 'wall_style', 'footing',
           'footing_representation', 'footing_style', 'west_void_margin', 'west_opening', 'west_opening_width',
           'wo_representation', 'west_opening_coords', 'south_opening', 'south_opening_width', 'so_representation',
           'roof', 'roof_representation_south', 'roof_representation_north', 'roof_downward_offset', 'south_roof',
           'north_roof', 'roof_style', 'north_wall_representation', 'north_wall', 'east_wall', 'south_roof_clipping',
           'north_roof_clipping', 'east_wall_representation', 'west_wall', 'west_wall_representation',
           'west_opening_copy', 'connection_args', 'rel_connect_paths', 'point_list', 'curve_on_relating',
           'connection_curve', 'terrain_control_points', 'degree', 'multiplicity', 'brick', 'wall_layerset',
           'brick_layer', 'stair_flight_params', 'stair_flight', 'stair_points', 'stair_flight_curve',
           'stair_flight_profile', 'stair_flight_representation', 'stair_style', 'door', 'door_opening',
           'door_opening_representation', 'door_representation', 'door_style', 'window_right',
           'window_right_representation', 'window_west', 'window_west_representation', 'window_left',
           'window_left_representation', 'window_style', 'json_logger', 'ifc_path']

# %% ../nbs/00_generation.ipynb 9
import sys
from pathlib import Path
from collections import defaultdict
from mathutils import Vector
import numpy as np
import ifcopenshell
import ifcopenshell.api
import ifcopenshell.api.owner
import ifcopenshell.api.owner.settings
import ifcopenshell.api.material
import ifcopenshell.api.geometry
import ifcopenshell.validate

from IfcOpenHouse.ios_utils import (
    IfcOpenShellPythonAPI, placement_matrix, clipping, ColourRGB, TerrainBuildMethod, 
    build_native_bspline_terrain, build_tesselated_occ_terrain, ios_entity_overwrite_hook
)

# %% ../nbs/00_generation.ipynb 12
# Data definition
project_name = 'IFC Open House'
author_details = {'given_name': 'Carlos', 'family_name': 'V', 'identification': 'CV'}
author_role = 'CIVILENGINEER'
organization_details = {'name': 'OSArch', 'identification': 'OSArch'}
site_name, building_name, storey_name = 'OSArch Land', 'Open house', 'Ground floor'

# All dimensions in meters
storey_size = Vector([10., 5., 3.])
wall_thickness = 0.36
footing_ledge = 0.05
footing_size = Vector([
    storey_size.x + 2 * (wall_thickness + footing_ledge),
    storey_size.y + 2 * (wall_thickness + footing_ledge),
    2.
])
roof_ledge = Vector([0.1, 0.22])
roof_thickness = 0.36
roof_angle = 45. # degrees
roof_angle_sin = float(np.sin(roof_angle * np.pi/180))
roof_angle_cos = float(np.cos(roof_angle * np.pi/180))
roof_height = float(
    (storey_size.y / 2 + wall_thickness + roof_ledge.y) * np.tan(roof_angle * np.pi / 180)
)
roof_size = Vector([
    storey_size.x + 2 * (wall_thickness + roof_ledge.x),
    storey_size.y + 2 * (wall_thickness + roof_ledge.y),
    roof_height
])
door_horizontal_offset = 1.6
window_base_height = 0.4
right_window_horizontal_offset = 2.
stair_width = 1.2

# Colours for surface styles
wall_colour = ColourRGB(.75, 0.73, 0.68)
footing_colour = ColourRGB(.38, 0.4, 0.42)
roof_colour = ColourRGB(.24, 0.08, 0.04)
terrain_colour = ColourRGB(.15, 0.25, 0.05)
door_colour = ColourRGB(.8, .8, .8)
window_colour = ColourRGB(.5, 0.4, 0.3, transparency=0.8)
stair_colour = ColourRGB(.45, 0.47, 0.56)

# Choice of terrain building method. Use NONE if unsure about the viewer capabilities.   
terrain_build_method = TerrainBuildMethod.TESSELATE_OCC_SHAPE

# Door and window geometric info is defined in a separate file due to its complexity
from .opening_data import door_params, single_window_params, triple_window_params


# %% ../nbs/00_generation.ipynb 15
# Little trickery to ease the use of the ifcopenshell.api when scripting
ios = IfcOpenShellPythonAPI()  #q1: thoughts about a data-scientish "import ifcopenshell.api as ios"?

# standard use      -> ifcopenshell.api.run('root.create_entity', file, ifc_class='IfcWall')
# with the trickery -> ios.root.create_entity(file, ifc_class='IfcWall')

# It will reduce the overall string overhead, as well as the length of the API calls
# However, it will not help with static typing autocomplete and help
# Bear in mind that currently, this is not a canonical use of IfcOpenShell


# Setting up the project
file = ios.project.create_file(version='IFC4')
# Don't use 2X3 in 2023! It's terribly outdated and lacks many useful classes. This simple
# project uses many >=IFC4 features, and hence selecting 'IFC2X3' here would only lead to issues.
# Pending to use 4x3 (much better docs) when ios defaults to IFC4X3_TC1 and IFC.js supports it

project = ios.root.create_entity(file, ifc_class='IfcProject', name=project_name)
ios.project.assign_declaration(file, definition=project, relating_context=project)  #q2: from my ignorance, is this necessary?
ios.unit.assign_unit(
    file, length={'is_metric': True, 'raw': 'METERS'}, area={'is_metric': True, 'raw': 'METERS'},
    volume={'is_metric': True, 'raw': 'METERS'}
)
ctx = ios.context.add_context(file, context_type='Model')
body = ios.context.add_context(  #q3: isn't this screaming for "context.add_subcontext"? also, context_type may be redundant
    file, context_type='Model', context_identifier='Body', target_view='MODEL_VIEW', parent=ctx
)

# We allow for live overwriting of IfcOpenShell entities within the notebook environment
# Only use this sorcery when experimenting in Jupyter Notebooks, never in production
sys.addaudithook(
    ios_entity_overwrite_hook(file, sys.modules[__name__], do_not_delete=[project, ctx, body])
)

# %% ../nbs/00_generation.ipynb 19
application = ios.owner.add_application(file)
person = ios.owner.add_person(file, **author_details)
organisation = ios.owner.add_organisation(file, **organization_details)
user = ios.owner.add_person_and_organisation(file, person=person, organisation=organisation)
ios.owner.add_role(file, assigned_object=organisation, role=author_role)
actor = ios.owner.add_actor(file, actor=user)
ifcopenshell.api.owner.settings.get_user = lambda x: user
ifcopenshell.api.owner.settings.get_application = lambda x: application

# %% ../nbs/00_generation.ipynb 22
site = ios.root.create_entity(file, ifc_class='IfcSite', name=site_name)
ios.aggregate.assign_object(file, product=site, relating_object=project)

building = ios.root.create_entity(file, ifc_class='IfcBuilding', name=building_name)
ios.aggregate.assign_object(file, product=building, relating_object=site)

storey = ios.root.create_entity(file, ifc_class='IfcBuildingStorey', name=storey_name)
ios.aggregate.assign_object(file, product=storey, relating_object=building);

# %% ../nbs/00_generation.ipynb 24
pset_site_common = ios.pset.add_pset(file, product=site, name='Pset_SiteCommon')
ios.pset.edit_pset(file, pset=pset_site_common, properties={'TotalArea': 400.})

# %% ../nbs/00_generation.ipynb 27
south_wall = ios.root.create_entity(file, ifc_class='IfcWall', name='South wall', predefined_type='SOLIDWALL')

# %% ../nbs/00_generation.ipynb 29
south_wall.is_a()

# %% ../nbs/00_generation.ipynb 31
south_wall.get_info()

# %% ../nbs/00_generation.ipynb 33
south_wall.Description = 'This is my first wall with the IfcOpenShell Python API!'

# %% ../nbs/00_generation.ipynb 35
ios.spatial.assign_container(file, product=south_wall, relating_structure=storey);

# %% ../nbs/00_generation.ipynb 37
south_wall_representation = ios.geometry.add_wall_representation(
    file, context=body, length=storey_size.x + 2 * wall_thickness, height=storey_size.z, 
    thickness=wall_thickness
)
ios.geometry.assign_representation(file, product=south_wall, representation=south_wall_representation)
ios.geometry.edit_object_placement(
    file, product=south_wall, matrix=placement_matrix(
        [-storey_size.x / 2 - wall_thickness, -wall_thickness / 2, 0.]
    )
);  #q4: why a matrix if Y is going to be ignored? why not just pass the placement coords + optionals x_local, z_local and scale?

# %% ../nbs/00_generation.ipynb 39
wall_style = ios.style.add_style(file)
ios.style.add_surface_style(
    file, style=wall_style, ifc_class='IfcSurfaceStyleShading', attributes=wall_colour.info
)
ios.style.assign_representation_styles(
    file, shape_representation=south_wall_representation, styles=[wall_style]
);

# %% ../nbs/00_generation.ipynb 42
footing = ios.root.create_entity(file, ifc_class='IfcFooting', name='Footing', predefined_type='STRIP_FOOTING')
ios.spatial.assign_container(file, product=footing, relating_structure=storey)
footing_representation = ios.geometry.add_wall_representation(
    file, context=body, length=footing_size.x, height=footing_size.z, thickness=footing_size.y
)
ios.geometry.assign_representation(file, product=footing, representation=footing_representation)
ios.geometry.edit_object_placement(
    file, product=footing, matrix=placement_matrix(
        [-footing_size.x/2, -wall_thickness/2 - footing_ledge, -footing_size.z]
    )
)
footing_style = ios.style.add_style(file)
ios.style.add_surface_style(
    file, style=footing_style, ifc_class='IfcSurfaceStyleShading', attributes=footing_colour.info
)
ios.style.assign_representation_styles(
    file, shape_representation=footing_representation, styles=[footing_style]
);

# %% ../nbs/00_generation.ipynb 45
west_void_margin = 0.5
west_opening = ios.root.create_entity(file, ifc_class='IfcOpeningElement')
west_opening_width = 2 * single_window_params['overall_width']
wo_representation = ios.geometry.add_wall_representation(
    file, context=body, 
    length=triple_window_params['overall_width'] + west_void_margin, 
    height=triple_window_params['overall_height'],
    thickness=west_opening_width
)
ios.geometry.assign_representation(file, product=west_opening, representation=wo_representation)
west_opening_coords = [
    (
        -storey_size.x / 2 - wall_thickness - west_void_margin 
        + single_window_params['lining_properties']['LiningOffset']
    ), 
    (
        -west_opening_width / 2 - wall_thickness / 3
        + triple_window_params['lining_properties']['LiningOffset'] 
        + triple_window_params['lining_properties']['LiningDepth']
    ), 
    window_base_height
]
ios.geometry.edit_object_placement(
    file, product=west_opening, matrix=placement_matrix(west_opening_coords)
)
ios.void.add_opening(file, opening=west_opening, element=south_wall)

south_opening = ios.root.create_entity(file, ifc_class='IfcOpeningElement')
south_opening_width = 3.
so_representation = ios.geometry.add_wall_representation(
    file, context=body, length=single_window_params['overall_width'], 
    height=single_window_params['overall_height'], thickness=south_opening_width
)
ios.geometry.assign_representation(file, product=south_opening, representation=so_representation)
ios.geometry.edit_object_placement(
    file, product=south_opening, matrix=placement_matrix(
        [right_window_horizontal_offset, -south_opening_width / 2, window_base_height]
    )
)
ios.void.add_opening(file, opening=south_opening, element=south_wall);

# %% ../nbs/00_generation.ipynb 48
roof = ios.root.create_entity(file, ifc_class='IfcRoof', name='Roof', predefined_type='GABLE_ROOF')
ios.spatial.assign_container(file, product=roof, relating_structure=storey)
roof_representation_south = ios.geometry.add_wall_representation(
    file, context=body, length=roof_size.x, height=roof_size.y / 2, thickness=roof_thickness, 
    x_angle=(roof_angle) * np.pi / 180
)
roof_representation_north = ifcopenshell.util.element.copy_deep(file, roof_representation_south)
#q5: add_slab_representation doesn't accept width and depth? isn't it strange calling it add_wall
#if we're using it for everything? do "add_wall_representation", "add_slab_representation" and 
#"add_profile_representation" add all of them an IfcExtrudedAreaSolid? Would it make any sense to 
#add a single "add_extruded_representation" instead? As a higher level API call than shape_builder

roof_downward_offset = (roof_ledge.y + wall_thickness / 2) * np.tan(roof_angle * np.pi / 180)

south_roof = ios.root.create_entity(file, ifc_class='IfcSlab', name='South roof', predefined_type='ROOF')
ios.geometry.assign_representation(file, product=south_roof, representation=roof_representation_south)
ios.geometry.edit_object_placement(
    file, product=south_roof, matrix=placement_matrix(
        [roof_size.x / 2, -roof_ledge.y - wall_thickness / 2, storey_size.z - roof_downward_offset], 
        x_local=[-1., 0., 0.], z_local=[0., 1., 0.]
    )
)

north_roof = ios.root.create_entity(file, ifc_class='IfcSlab', name='North roof', predefined_type='ROOF')
ios.geometry.assign_representation(file, product=north_roof, representation=roof_representation_north)
ios.geometry.edit_object_placement(
    file, product=north_roof, matrix=placement_matrix(
        [
            -roof_size.x / 2, 
            (storey_size.y + wall_thickness) / 2, 
            storey_size.z - roof_downward_offset + roof_size.z + roof_thickness / roof_angle_cos
        ], x_local=[1., 0., 0.], z_local=[0., 1., 0.]
    )
)

ios.aggregate.assign_object(file, product=south_roof, relating_object=roof)
ios.aggregate.assign_object(file, product=north_roof, relating_object=roof)

roof_style = ios.style.add_style(file)
ios.style.add_surface_style(
    file, style=roof_style, ifc_class='IfcSurfaceStyleShading', attributes=roof_colour.info
)
ios.style.assign_representation_styles(
    file, shape_representation=roof_representation_south, styles=[roof_style]
)
ios.style.assign_representation_styles(
    file, shape_representation=roof_representation_north, styles=[roof_style]
);

# %% ../nbs/00_generation.ipynb 51
north_wall_representation = ifcopenshell.util.element.copy_deep(file, south_wall_representation)
north_wall = ios.root.create_entity(file, ifc_class='IfcWall', name='North wall', predefined_type='SOLIDWALL')
ios.spatial.assign_container(file, product=north_wall, relating_structure=storey)
ios.geometry.assign_representation(file, product=north_wall, representation=north_wall_representation)
ios.geometry.edit_object_placement(
    file, product=north_wall, matrix=placement_matrix(
        [-storey_size.x/2 - wall_thickness, storey_size.y + wall_thickness / 2, 0.]
    )
)
ios.style.assign_representation_styles(
    file, shape_representation=north_wall_representation, styles=[wall_style]
);

# %% ../nbs/00_generation.ipynb 53
east_wall = ios.root.create_entity(
    file, ifc_class='IfcWall', name='East wall', predefined_type='SOLIDWALL'
)
ios.spatial.assign_container(file, product=east_wall, relating_structure=storey)

south_roof_clipping = clipping(
    [0., wall_thickness / 2, storey_size.z], x_dir=[1., 0., 0.], 
    z_dir=[0., -roof_angle_sin, roof_angle_cos]
)
north_roof_clipping = clipping(
    [0., storey_size.y + 3 / 2 * wall_thickness, storey_size.z], x_dir=[1., 0., 0.], 
    z_dir=[0., roof_angle_sin, roof_angle_cos]
)

east_wall_representation = ios.geometry.add_wall_representation(
    file, context=body, length=wall_thickness, height=storey_size.z + roof_size.z, 
    thickness=storey_size.y + 2 * wall_thickness, clippings=[south_roof_clipping, north_roof_clipping]
)

ios.geometry.assign_representation(file, product=east_wall, representation=east_wall_representation)
ios.geometry.edit_object_placement(
    file, product=east_wall, matrix=placement_matrix([storey_size.x / 2, -wall_thickness / 2, 0.])
)

ios.style.assign_representation_styles(
    file, shape_representation=east_wall_representation, styles=[wall_style]
);

# %% ../nbs/00_generation.ipynb 55
west_wall = ios.root.create_entity(
    file, ifc_class='IfcWall', name='West wall', predefined_type='SOLIDWALL'
)
ios.spatial.assign_container(file, product=west_wall, relating_structure=storey)

west_wall_representation = ifcopenshell.util.element.copy_deep(file, east_wall_representation)
ios.geometry.assign_representation(file, product=west_wall, representation=west_wall_representation)
ios.geometry.edit_object_placement(
    file, product=west_wall, matrix=placement_matrix(
        [-storey_size.x / 2 - wall_thickness, -wall_thickness / 2, 0.]
    )
)

west_opening_copy = ifcopenshell.util.element.copy_deep(file, west_opening)
ios.geometry.edit_object_placement(
    file, product=west_opening_copy, matrix=placement_matrix(west_opening_coords)
)
ios.void.add_opening(file, opening=west_opening_copy, element=west_wall)

ios.style.assign_representation_styles(
    file, shape_representation=west_wall_representation, styles=[wall_style]
);

# %% ../nbs/00_generation.ipynb 57
connection_args = {'relating_connection': 'ATEND', 'related_connection': 'ATSTART'}

rel_connect_paths = [
    ios.geometry.connect_path(
        file, relating_element=south_wall, related_element=east_wall, **connection_args
    ),
    ios.geometry.connect_path(
        file, relating_element=east_wall, related_element=north_wall, **connection_args
    ),
    ios.geometry.connect_path(
        file, relating_element=north_wall, related_element=west_wall, **connection_args
    ),
    ios.geometry.connect_path(
        file, relating_element=west_wall, related_element=south_wall, **connection_args
    )
]

#q7: do IfcRelConnectsPathElements with ConnectionGeometry work in any viewer? is this done like this?
# Original IfcOpenHouse had half a wall thickness less of extension per wall end, I bet it's better for
# qto's, but how is the way to properly make connections and to have a proper viz of them in IFC?
point_list = file.create_entity('IfcCartesianPointList2D', CoordList = [[-1., -1.], [1., 1.]])
curve_on_relating = file.create_entity('IfcIndexedPolyCurve', Points=point_list)
connection_curve = file.create_entity(
    'IfcConnectionCurveGeometry', CurveOnRelatingElement=curve_on_relating
)

for path in rel_connect_paths:
    path.ConnectionGeometry = connection_curve

# %% ../nbs/00_generation.ipynb 60
terrain_control_points = [  # obtained from the original IfcOpenHouse
    [( -10., -10., -4.13), ( -10., -4.33, -4.13), (-10., 0., -5.13), ( -10., 4.33, -7.13), ( -10., 10., -7.13)],
    [(-3.33, -10., -5.13), (-7.67, -3.67,    5.), ( -9., 0.,    1.), (-7.67, 7.67,    6.), (-3.33, 10., -4.13)],
    [(   0., -10., -5.53), (   0., -3.67,    3.), (  0., 0.,  -12.), (   0., 7.67,   1.5), (   0., 10., -4.13)],
    [( 3.33, -10., -6.13), ( 7.67, -3.67,    6.), (  9., 0.,    5.), ( 7.67,   9.,    7.), ( 3.33, 10., -4.13)],
    [(  10., -10., -6.13), (  10., -4.33, -5.13), ( 10., 0., -4.13), (  10., 4.33, -4.13), (  10., 10., -8.13)]
]

degree, multiplicity = 4, 5

if terrain_build_method == TerrainBuildMethod.NATIVE_BSPLINE:
    terrain_representation = build_native_bspline_terrain(
        file, body, terrain_control_points, degree, multiplicity
    )
    
elif terrain_build_method == TerrainBuildMethod.TESSELATE_OCC_SHAPE:
    deflection = 0.01
    terrain_representation = build_tesselated_occ_terrain(
        file, body, terrain_control_points, degree, multiplicity, deflection
    )

if terrain_build_method != TerrainBuildMethod.NONE:
    # If we have produced an IfcShapeRepresentation, by any of the previous methods, we assign it
    # to the IfcSite and also assign it a style.
    
    ios.geometry.assign_representation(file, product=site, representation=terrain_representation)
    terrain_style = ios.style.add_style(file)
    ios.style.add_surface_style(
        file, style=terrain_style, ifc_class='IfcSurfaceStyleShading', attributes=terrain_colour.info
    )
    ios.style.assign_representation_styles(
        file, shape_representation=terrain_representation, styles=[terrain_style]
    );

# %% ../nbs/00_generation.ipynb 63
brick = ios.material.add_material(file, name='Brick', category='brick')
wall_layerset = ios.material.add_material_set(file, name='Wall', set_type='IfcMaterialLayerSet')
brick_layer = ios.material.add_layer(file, layer_set=wall_layerset, material=brick)
ios.material.edit_layer(file, layer=brick_layer, attributes={'LayerThickness': wall_thickness})

#q9: Original IfcOpenHouse used usages. In current IFC, are usages without types a good idea? 
# Do I add usages or types?

for wall in [south_wall, north_wall, east_wall, west_wall]:
    ios.material.assign_material(file, product=wall, type='IfcMaterialLayerSet', material=wall_layerset)

# %% ../nbs/00_generation.ipynb 66
stair_flight_params = {'NumberOfRisers': 2, 'NumberOfTreads': 2, 'RiserHeight': 0.2, 'TreadLength': 0.25}
stair_flight = ios.root.create_entity(file, ifc_class='IfcStairFlight', name='Main entrance stair', predefined_type='STRAIGHT')
ios.spatial.assign_container(file, product=stair_flight, relating_structure=storey)
for attr, value in stair_flight_params.items():
    setattr(stair_flight, attr, value)  # the entity is monkey-patched with its IFC compliant attributes

stair_points = []  # Staircase cross-sectional profile 2D points
for step in range(stair_flight_params['NumberOfRisers'] + 1):
    next_step = 0 if step == stair_flight_params['NumberOfRisers'] else step + 1
    stair_points.extend([
        (step * stair_flight_params['TreadLength'], step * stair_flight_params['RiserHeight']),
        (next_step * stair_flight_params['TreadLength'], step * stair_flight_params['RiserHeight']),
    ])

stair_flight_curve = file.create_entity(
    'IfcIndexedPolyCurve', file.create_entity('IfcCartesianPointList2D', stair_points), None, False
)
stair_flight_profile = file.create_entity('IfcArbitraryClosedProfileDef', 'AREA', None, stair_flight_curve)
stair_flight_representation = ios.geometry.add_profile_representation(
    file, context=body, profile=stair_flight_profile, depth=stair_width
)

ios.geometry.assign_representation(file, product=stair_flight, representation=stair_flight_representation)
ios.geometry.edit_object_placement(
    file, product=stair_flight, matrix=placement_matrix(
        [footing_size.x / 2, door_horizontal_offset + (door_params['overall_width'] - stair_width) / 2, 0.],
        z_local=[0., 1., 0.]
    )
)

stair_style = ios.style.add_style(file)
ios.style.add_surface_style(
    file, style=stair_style, ifc_class='IfcSurfaceStyleShading', attributes=stair_colour.info
)
ios.style.assign_representation_styles(
    file, shape_representation=stair_flight_representation, styles=[stair_style]
);

# %% ../nbs/00_generation.ipynb 69
door = ios.root.create_entity(file, ifc_class='IfcDoor', name='Main door', predefined_type='DOOR')
ios.spatial.assign_container(file, product=door, relating_structure=storey)

door_opening = ios.root.create_entity(file, ifc_class='IfcOpeningElement')
door_opening_representation = ios.geometry.add_wall_representation(
    file, context=body, length=door_params['overall_width'], height=door_params['overall_height'], 
    thickness=door_params['overall_width']
)
ios.geometry.assign_representation(
    file, product=door_opening, representation=door_opening_representation
)
ios.geometry.edit_object_placement(
    file, product=door_opening, matrix=placement_matrix(
        [storey_size.x / 2 - door_params['overall_width'] / 2 , door_horizontal_offset, 0.]
    )
)
ios.void.add_opening(file, opening=door_opening, element=east_wall)

door_representation = ios.geometry.add_door_representation(  # requires mathutils
    file, context=body, **door_params
)
ios.geometry.edit_object_placement(
    file, product=door, matrix=placement_matrix(
        [storey_size.x / 2 + wall_thickness / 4, door_horizontal_offset, 0.],
        x_local=[0., 1., 0.]  # door is rotated into the east wall
    )
)
ios.geometry.assign_representation(file, product=door, representation=door_representation)
ios.void.add_filling(file, opening=door_opening, element=door)

door_style = ios.style.add_style(file)
ios.style.add_surface_style(
    file, style=door_style, ifc_class='IfcSurfaceStyleShading', attributes=door_colour.info
)
ios.style.assign_representation_styles(
    file, shape_representation=door_representation, styles=[door_style]
);

# %% ../nbs/00_generation.ipynb 72
window_right = ios.root.create_entity(
    file, ifc_class='IfcWindow', name='Right window', predefined_type='WINDOW'
)
window_right.PartitioningType = single_window_params['partition_type']  #q6: couldn't this fit into the previous call?
window_right_representation = ios.geometry.add_window_representation(  # requires mathutils
    file, context=body, **single_window_params
)
ios.spatial.assign_container(file, product=window_right, relating_structure=storey)
ios.geometry.edit_object_placement(
    file, product=window_right, matrix=placement_matrix(
        [right_window_horizontal_offset, -wall_thickness / 3, window_base_height]
    )
)
ios.geometry.assign_representation(
    file, product=window_right, representation=window_right_representation
)
ios.void.add_filling(file, opening=south_opening, element=window_right)

window_west = ios.root.create_entity(
    file, ifc_class='IfcWindow', name='West window', predefined_type='WINDOW'
)
window_west.PartitioningType = single_window_params['partition_type']
window_west_representation = ios.geometry.add_window_representation(
    file, context=body, **single_window_params
)
ios.spatial.assign_container(file, product=window_west, relating_structure=storey)
ios.geometry.edit_object_placement(
    file, product=window_west, matrix=placement_matrix(
        [
            -storey_size.x / 2 - wall_thickness,
            (
                + single_window_params['overall_width'] - wall_thickness / 3 
                + triple_window_params['lining_properties']['LiningOffset'] 
                + triple_window_params['lining_properties']['LiningDepth']
            ), 
            window_base_height
        ], x_local=[0., -1., 0.]
    )
)
ios.geometry.assign_representation(
    file, product=window_west, representation=window_west_representation
)
ios.void.add_filling(file, opening=west_opening_copy, element=window_west)

window_left = ios.root.create_entity(
    file, ifc_class='IfcWindow', name='Left Window', predefined_type='WINDOW'
)
window_left.PartitioningType = triple_window_params['partition_type']
window_left_representation = ios.geometry.add_window_representation(
    file, context=body, **triple_window_params
)
ios.spatial.assign_container(file, product=window_left, relating_structure=storey)
ios.geometry.edit_object_placement(
    file, product=window_left, matrix=placement_matrix(
        [
            (
                -storey_size.x / 2 - wall_thickness
                + single_window_params['lining_properties']['LiningOffset']
            ),
            -wall_thickness / 3,
            window_base_height]
    )
)
ios.geometry.assign_representation(
    file, product=window_left, representation=window_left_representation
)
ios.void.add_filling(file, opening=west_opening, element=window_left)

window_style = ios.style.add_style(file)
ios.style.add_surface_style(
    file, style=window_style, ifc_class='IfcSurfaceStyleShading', attributes=window_colour.info
)
ios.style.assign_representation_styles( #q10: Will it be possible to assign different styles to the panel and the lining?
    file, shape_representation=window_right_representation, styles=[window_style]
)
ios.style.assign_representation_styles(
    file, shape_representation=window_west_representation, styles=[window_style]
)
ios.style.assign_representation_styles(
    file, shape_representation=window_left_representation, styles=[window_style]
);

# %% ../nbs/00_generation.ipynb 75
json_logger = ifcopenshell.validate.json_logger()
ifcopenshell.validate.validate(file, json_logger)
json_logger.statements[:min(3, len(json_logger.statements))]  # Showing only first 3 here

# %% ../nbs/00_generation.ipynb 77
set([issue['attribute'] for issue in json_logger.statements])

# %% ../nbs/00_generation.ipynb 86
ifc_path = Path('..') / 'ifc' / 'IfcOpenHouse.ifc'
file.write(ifc_path)
